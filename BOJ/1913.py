N = int(input())
K = int(input())

mat = [[0] * N for _ in range(N)]

# 좌표에 적을 값
M = N * N

# 내 좌표
r, c = 0, 0

# 델타 반시계, 하우상좌
dr = [1, 0, -1, 0]
dc = [0, 1, 0, -1]
# 델타의 인덱스
di = 0

# K값 찾기
kr, kc = 0, 0

# 함수 만들기
def make_snail(N, K):
    global M, r, c, di, kr, kc
    
    while M >= 1:
        # 범위 안이고 값이 0일 때
        if (0 <= r < N and 0 <= c < N
            and mat[r][c] == 0):
            mat[r][c] = M
            # print("orig", r, c, di, M)
            
            # K값 찾기 (인덱스 + 1)
            if mat[r][c] == K:
                kr, kc = r + 1, c + 1
            
            # 다음 칸으로 가기
            r = r + dr[di]
            c = c + dc[di]
            M -= 1
        
        # 범위 밖이거나 값이 0이 아닐 때
        else:
            # 한칸 전으로 돌아가기
            r = r - dr[di]
            c = c - dc[di]
            
            # 방향전환: 원형으로 돌아가며 i값을 더함 
            # 길이 = 4, 나머지 = 0, 1, 2, 3
            di = (di + 1) % 4

            # 다음 칸으로 가기
            r = r + dr[di]
            c = c + dc[di]
            # print("else", r, c, di, M)

# 함수 실행
make_snail(N, K)

# 출력 부분 (*로 출력하면 리스트에서 나옴, 공백 자동)
for i in range(N):
    print(*mat[i], end='\n')

print(kr, kc)

'''
함수 만들기:
0 0, 1 0, 2 0, ... 6 0: r + 1
6 1, 6 2, 7 3, ... 6 6: c + 1
5 6, 4 6, 4 6, ... 0 6: r - 1
0 5, 0 4, 0 3, ... 0 1: c - 1

범위에서 벗어나거나 행렬값이 0이 아니면...
= 범위 안이거나 채워진 값이 0일 때는
같은 ri[i], ci[i]값을 가지면 된다.

델타 인덱스:
델타의 인덱스값은 r, c 나눠서 쓸 필요 없이
하나로 쓰면 된다.
'''

'''
주어진 값 N, K:
표의 크기는 N * N, 특정값 좌표는 K 이다.
인덱스는 N - 1까지다.

달팽이 만들기:
큰 값부터 값 채워가기
값이 존재하지 않으면 숫자를 채우고
아래로->오른쪽으로->위로->왼쪽으로 반복,
왼쪽으로 채우고 나서 왼쪽 값이 채워진 상태라면
다시 아래로 진행,
열과 행은 하나씩 줄어들게 됨
마지막 값 1에 도달하면 종료

특정값 K 찾기:
진행하다가 만약 특정값과 행렬값이 일치하면
좌표값을 저장, 인덱스값이므로 + 1해야 한다.
'''